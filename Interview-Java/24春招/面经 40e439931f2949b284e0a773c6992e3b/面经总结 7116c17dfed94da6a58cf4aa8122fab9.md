# 面经总结

# Todo List

# 1. Java NIO

![Untitled](%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93%207116c17dfed94da6a58cf4aa8122fab9/Untitled.png)

Java NIO 的原理基于几个核心概念：缓冲区（Buffers）、通道（Channels）、选择器（Selectors）以及非阻塞 I/O。以下是这些概念的简要介绍和原理说明：

1. **缓冲区（Buffers）**：
    
    **NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。**
    缓冲区是 NIO 中的一个关键概念，它是数据的容器，可以是字节、字符或其他类型的数据。缓冲区不是直接与流直接交互，而是作为数据的临时存储区域，用于在读取和写入操作中暂存数据。缓冲区有多种类型，如 ByteBuffer、CharBuffer 等，每种类型都有其特定的操作和行为。缓冲区具有容量（capacity）、限制（limit）和位置（position）三个属性，这些属性共同定义了缓冲区中数据的存储和访问方式。
    
2. **通道（Channels）**：
    
    **Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。**
    通道是 NIO 中用于数据传输的对象。与传统的流（Streams）不同，流是单向的（只能读或只能写），而通道可以是双向的，即可以同时进行读写操作。通道可以是文件通道（FileChannel），也可以是套接字通道（SocketChannel 和 ServerSocketChannel），用于网络通信。通道是非阻塞的，这意味着它们可以同时处理多个连接，而不会因为一个阻塞操作而影响其他操作。
    
3. **选择器（Selectors）**：
选择器是 NIO 中用于多路复用 I/O 的工具。它允许单个线程监控多个输入通道，判断通道是否有事件发生（如连接请求、数据到达等），并根据事件类型进行相应的处理。这种方式极大地提高了程序在处理多个 I/O 通道时的效率，因为它避免了为每个通道分配单独的线程或使用多线程模型，从而减少了资源消耗和上下文切换的开销。
4. **非阻塞 I/O**：
NIO 的通道默认是非阻塞的，这意味着在进行读取或写入操作时，如果没有数据可用，通道不会阻塞当前线程，而是立即返回。这允许线程在等待数据的同时处理其他任务。非阻塞 I/O 是通过底层的操作系统支持实现的，它依赖于操作系统提供的异步事件通知机制。

这些概念共同构成了 Java NIO 的基础，使得 NIO 能够提供高性能的 I/O 操作，特别是在高并发和大量数据传输的场景中。通过使用缓冲区来优化数据读写，通道来进行双向通信，选择器来实现多路复用，以及非阻塞 I/O 来提高线程的利用率，Java NIO 提供了一种与传统 I/O 完全不同的高效数据处理方式。

# 2. select、poll、epoll

> 文件描述符（File Descriptor）是操作系统中用于标识一个打开的文件、目录、管道、套接字等文件类型的对象的非负整数。在类Unix操作系统中，几乎所有的I/O操作都是通过文件描述符来完成的。文件描述符的主要用途和特点包括：
> 
> 1. **唯一标识**：每个打开的文件或资源都有一个唯一的文件描述符，即使是同名的文件，每次打开也会得到不同的文件描述符。
> 2. **抽象化**：文件描述符提供了一个抽象层，使得不同类型的文件和资源可以通过统一的接口进行操作。例如，你可以对一个普通的文件和一个网络套接字使用相同的读取和写入系统调用。
> 3. **I/O 操作**：文件描述符是执行I/O操作的关键。通过文件描述符，应用程序可以使用如 `read`、`write`、`close` 等系统调用来读取数据、写入数据和关闭文件。
> 4. **标准I/O**：文件描述符也用于标准输入（stdin，通常为0）、标准输出（stdout，通常为1）和标准错误（stderr，通常为2）。这些是程序运行时默认打开的文件描述符，分别用于程序的输入、输出和错误信息的输出。
> 5. **多路复用**：在使用如 `select`、`poll` 或 `epoll` 等I/O多路复用技术时，文件描述符用于指定哪些文件或套接字需要监控，以及监控它们的哪些事件（如可读、可写、异常等）。
> 6. **继承性**：在创建子进程时，父进程可以决定哪些文件描述符要传递给子进程。这允许子进程访问父进程打开的资源。
> 7. **资源管理**：通过文件描述符，操作系统可以跟踪和管理所有打开的文件和其他资源，确保资源被正确关闭和释放。
> 
> 文件描述符是操作系统提供的一种高效、灵活的资源管理方式，它使得程序员可以通过统一的接口处理各种类型的文件和资源，极大地简化了文件I/O操作的编程模型。
> 

`select`、`poll` 和 `epoll` 都是 I/O 多路复用的技术，它们允许单个线程同时监控多个文件描述符（通常是套接字），以便在这些文件描述符中的任何一个变得可读或可写时得到通知。下面是它们的原理和区别：

### select 的原理和特点

- **位图机制**：`select` 使用三张位图（读、写、异常），分别对应不同类型的事件。应用程序首先将需要监控的文件描述符集合设置到这些位图中，然后调用 `select` 系统调用。`select` 会阻塞等待，直到某个文件描述符就绪或者超时。
- **效率问题**：`select` 的效率随着监控的文件描述符数量增加而降低，因为它需要复制文件描述符集合到内核和用户空间，并且每次调用都会检查所有文件描述符，不管它们是否就绪。

### poll 的原理和特点

- **pollfd 数组**：`poll` 使用一个 `pollfd` 结构体数组来监控每个文件描述符的状态。这个数组在用户空间，`poll` 函数会轮询这个数组，直到某个文件描述符就绪或者超时。
- **改进**：与 `select` 相比，`poll` 没有文件描述符数量的限制，因为它不依赖于位图，而是直接在用户空间操作。但是，`poll` 仍然需要遍历整个数组来查找就绪的文件描述符，这在大量文件描述符时效率仍然不高。

### epoll 的原理和特点

- **事件通知机制**：`epoll` 是 Linux 特有的 I/O 多路复用技术，它使用事件通知机制，只返回那些真正发生的事件的文件描述符，而不是像 `select` 和 `poll` 那样轮询所有文件描述符。
- **效率和扩展性**：`epoll` 在处理大量文件描述符时效率更高，因为它避免了不必要的遍历。`epoll` 有两种工作模式：`EPOLL_LT`（水平触发）和 `EPOLL_ET`（边缘触发）。边缘触发模式可以进一步提高效率，因为它只在状态发生变化时通知，而不是像水平触发模式那样只要条件满足就通知。
- **内核与用户空间**：`epoll` 通过 `epoll_ctl` 函数管理监控的文件描述符，并且维护一个事件列表，这个列表存储在内核空间，减少了用户空间和内核空间之间的数据复制。

### 区别总结

- **性能**：`epoll` 在处理大量并发连接时性能最佳，`poll` 次之，`select` 性能最差。
- **文件描述符限制**：`select` 有文件描述符数量的限制，`poll` 没有硬性限制，但实际应用中受内存限制，`epoll` 支持的文件描述符数量远超 `select` 和 `poll`。
- **事件处理方式**：`select` 和 `poll` 都是轮询机制，`epoll` 使用事件通知机制，只在事件发生时通知应用程序。
- **内核与用户空间交互**：`epoll` 减少了内核与用户空间的交互次数，因为它避免了每次调用都复制文件描述符集合。

在选择使用哪种技术时，需要根据应用程序的具体需求和运行环境来决定。对于需要处理大量并发连接的高性能服务器，`epoll` 通常是首选。

# 3. Java clone

[https://www.cnblogs.com/javastack/p/12759352.html](https://www.cnblogs.com/javastack/p/12759352.html)

调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部 。

![Untitled](%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93%207116c17dfed94da6a58cf4aa8122fab9/Untitled%201.png)

clone方法执行的是浅拷贝，**如果想要实现深拷贝，可以通过覆盖Object中的clone方法的方式来实现。**

```bash
static  class  Body  implements  Cloneable
{
    public  Head  head;
    public  Body()
    {}
    public  Body(Head  head)
    {
        this.head  =  head;
    }      
    @Override       
    protected  Object  clone()  throws  CloneNotSupportedException
    {
        Body  newBody  =    (Body)  super.clone();
        newBody.head  =   (Head)  head.clone();
        return  newBody;
    }
}
static  class  Head  implements  Cloneable
{
    public   Face  face;
    public  Head()
    {}
    public  Head(Face  face)
    {
        this.face  =  face;
    }      
    @Override       
    protected  Object  clone()  throws  CloneNotSupportedException
    {
        return  super.clone();
    }
}
public  static  void  main(String\[\]  args)  throws  CloneNotSupportedException
{
    Body  body  =  new  Body(new  Head());
    Body  body1  =   (Body)  body.clone();
    System.out.println("body == body1 : "  +  (body  ==  body1) );
    System.out.println("body.head == body1.head : "  +   (body.head  ==  body1.head));
}
```

打印结果:

```
body == body1 : false
body.head == body1.head : false
```

由此可见， body和body1内的head引用指向了不同的Head对象， 也就是说在clone Body对象的同时， 也拷贝了它所引用的Head对象， 进行了深拷贝。

# 4. Java treemap

[https://segmentfault.com/a/1190000021434060](https://segmentfault.com/a/1190000021434060)

- `TreeMap`的底层结构是红黑树，因此可以依赖红黑树的特性保证`key`有序，所有操作其实就是对红黑树的操作。
- 而因为红黑树的数据结构，所以插入、查询和删除时间复杂度都是O(logn)，但是删除和插入后可能需要调整树结构满足红黑树的规则，需要耗费性能。
- `TreeMap`的效率很高，还支持各种条件查找，甚至是范围查找和范围替换等等。

# 5. jmap VS jstack命令

[https://juejin.cn/post/6957903936657293319](https://juejin.cn/post/6957903936657293319)

jmap：**Memory Map for Java**用于生成堆转储快照**一般称为heapdump或dump文件**。同时它还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。说简单点就是它能用来**查看堆内存信息。**

![Untitled](%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93%207116c17dfed94da6a58cf4aa8122fab9/Untitled%202.png)

jstack：**Stack Trace for Java**命令用于生成JVM当前时刻的**线程快照。**线程快照就是当前JVM内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。线程出现停顿时通过jstack来查看各个线程的调用堆栈， 就可以获知没有响应的线程到底在后台做些什么事情，或者等待着什么资源。

# 6.AOP

有哪几种实现方式？

## **Spring AOP（运行时织入）**

[https://www.cnblogs.com/tuyang1129/p/12878549.html](https://www.cnblogs.com/tuyang1129/p/12878549.html)

`Spring`的`AOP`实现原理其实很简单，就是通过动态代理实现的。如果我们为`Spring`的某个`bean`配置了切面，那么`Spring`在创建这个`bean`的时候，实际上创建的是这个`bean`的一个代理对象，我们后续对`bean`中方法的调用，实际上调用的是代理类重写的代理方法。而`Spring`的`AOP`使用了两种动态代理，分别是JDK的动态代理，以及CGLib的动态代理。

Spring默认使用JDK的动态代理实现AOP，类如果实现了接口，Spring就会使用这种方式实现动态代理。**`JDK`**的动态代理存在限制，那就是被代理的类必须是一个实现了接口的类，代理类需要实现相同的接口，代理接口中声明的方法。若需要代理的类没有实现接口，此时**`JDK`**的动态代理将没有办法使用，于是**`Spring`**会使用**`CGLib`**的动态代理来生成代理对象。**`CGLib`**直接操作字节码，生成类的子类，重写类的方法完成代理。

JDK动态代理在内部使用反射机制来拦截代理对象的方法调用，通过实现`InvocationHandler`接口的`invoke`方法，可以拦截并自定义代理对象的方法调用。CGLIB通过字节码技术在运行时生成一个新的子类，来实现对目标类的代理。与JDK动态代理类似，CGLIB也提供了方法拦截的功能，但需要使用`MethodInterceptor`接口。

让我们通过一个简单的例子来展示JDK动态代理和CGLIB动态代理的使用。

### JDK动态代理示例

假设我们有一个`Rental`接口和一个实现该接口的`Movie`类。我们将创建一个代理对象，用于记录`Movie`对象的方法调用信息。

首先，定义`Rental`接口和`Movie`实现类：

```java
public interface Rental {
    void rent();
}

public class Movie implements Rental {
    @Override
    public void rent() {
        System.out.println("Renting a movie");
    }
}

```

接下来，使用JDK动态代理创建`Movie`的代理对象：

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class JDKProxyExample {
    public static void main(String[] args) {
        Rental movie = new Movie();
        Rental proxy = (Rental) Proxy.newProxyInstance(
                movie.getClass().getClassLoader(),
                new Class[]{Rental.class},
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxyInstance, Method method, Object[] args) throws Throwable {
                        System.out.println("Before method call");
                        Object result = method.invoke(movie, args);
                        System.out.println("After method call");
                        return result;
                    }
                }
        );

        proxy.rent(); // 输出: "Before method call", "Renting a movie", "After method call"
    }
}
```

### CGLIB动态代理示例

现在，我们将使用CGLIB来创建`Movie`类的动态代理。首先，我们需要添加CGLIB库的依赖到项目中。以下是Maven的依赖配置示例：

我们创建一个`Movie`类的方法拦截器：

```java
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

public class MovieInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("Before method call");
        Object result = method.invoke(obj, args);
        System.out.println("After method call");
        return result;
    }
}

```

最后，我们使用CGLIB创建`Movie`类的代理对象：

```java
import net.sf.cglib.proxy.Enhancer;

public class CGLIBProxyExample {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(Movie.class);
        enhancer.setCallback(new MovieInterceptor());
        Movie proxy = (Movie) enhancer.create();

        proxy.rent(); // 输出: "Before method call", "Renting a movie", "After method call"
    }
}
```

在这个例子中，我们首先定义了一个`Rental`接口和一个`Movie`实现类。然后，我们分别使用JDK动态代理和CGLIB动态代理创建了`Movie`的代理对象，并在代理对象的方法调用前后添加了日志输出。通过比较两个示例，你可以看到JDK动态代理和CGLIB动态代理在代码实现上的差异，以及它们如何用于创建代理对象并拦截方法调用。

## **Aspectj（编译or类加载时织入）**

一种就是我们常见的**基于java注解**切面描述的方法，这种方法兼容java语法，写起来十分方便，不需要IDE的额外语法检测支持；另外一种是**基于aspect文件**的切面描述方法，这种语法本身并不是java语法，因此写的时候需要IDE的插件支持才能进行语法检查。

三种织入方式：

[https://www.javadoop.com/post/aspectj](https://www.javadoop.com/post/aspectj)

1. compile-time：这是最简单的使用方式，在编译期的时候进行织入（即在编译的时候先修改了代码再进行编译），这样编译出来的 .class 文件已经织入了我们的代码，在 JVM 运行的时候其实就是加载了一个普通的被织入了代码的类。可以运用`aspectj-maven-plugin`插件来实现编译。
2. post-compile：编译后织入，增强已经编译出来的类，如我们要增强依赖的 jar 包中的某个类的某个方法。可以运用`aspectj-maven-plugin`插件来实现编译。
3. load-time：在 JVM 进行类加载的时候进行织入。这种方式不需要使用AspectJ编译器，而是在类加载到JVM时，通过自定义的类加载器来实现。AspectJ的weaver会在类加载时读取类文件，应用切点和通知，然后生成新的类文件来替换原始的类。

## **Java agent（更通用的字节码增强方式）**

Java Agent是通过`-javaagent`参数在JVM启动时或运行时附加到JVM上的一个组件。它使用JVM Tool Interface (JVMTI)来监听和修改JVM的行为。Java Agent可以在以下时机进行类文件的修改：

- **类加载前premain**：在类文件被加载到JVM之前，可以拦截并修改字节码。通过在java 的启动参数中添加 -javaagent:/jar包路径来进行字节码增强，随着java进程启动而启动。
- **类加载后agentmain**：对于已经加载到JVM中的类，可以在其被重新定义（redefine）时修改字节码。在运行时通过JVM Attach机制进行字节码增强。

## **Jvm SandBox**

# 7. Redis主从复制

[https://www.yuque.com/snailclimb/mf2z3k/ks9olb19hc9wse5k](https://www.yuque.com/snailclimb/mf2z3k/ks9olb19hc9wse5k)

# 8. 内连接、外连接和笛卡尔积的区别

![截屏2024-03-31 下午2.51.01.png](%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93%207116c17dfed94da6a58cf4aa8122fab9/%25E6%2588%25AA%25E5%25B1%258F2024-03-31_%25E4%25B8%258B%25E5%258D%25882.51.01.png)

# 9. TCP如何保证可靠传输

[https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html](https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html)

- **基于数据块传输**：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。
- **对失序数据包重新排序以及去重**：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。
- **校验和** : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
- **重传机制** : 在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。TCP 重传机制主要有：基于计时器的重传（也就是超时重传）、快速重传（基于接收端的反馈信息来引发重传）、SACK（在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了）、D-SACK（重复 SACK，在 SACK 的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了）。关于重传机制的详细介绍，可以查看[详解 TCP 超时与重传机制](https://zhuanlan.zhihu.com/p/101702312)这篇文章。
- **流量控制** : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。
- **拥塞控制** : 当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。
    - **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。
    - **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.
    - **快重传与快恢复：** 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。**有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。**有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

# 10. ICMP

一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。

PING 基于网络层的 **ICMP（Internet Control Message Protocol，互联网控制报文协议）**，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。

ICMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：

- **查询报文类型**：向目标主机发送请求并期望得到响应。
- **差错报文类型**：向源主机发送错误信息，用于报告网络中的错误情况。

PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。

- PING 命令会向目标主机发送 ICMP Echo Request。
- 如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。

# 11. 内存映射（Memory Mapping）

[https://zhuanlan.zhihu.com/p/507907660](https://zhuanlan.zhihu.com/p/507907660)

mmap 是一种内存映射文件的方法，即**将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系**。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read、write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：

![Untitled](%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93%207116c17dfed94da6a58cf4aa8122fab9/Untitled%203.png)

mmap 具有如下的特点：

1. mmap 向应用程序提供的内存访问接口是内存地址连续的，但是对应的磁盘文件的 block 可以不是地址连续的；
2. mmap 提供的内存空间是虚拟空间（虚拟内存），而不是物理空间（物理内存），因此完全可以分配远远大于物理内存大小的虚拟空间（例如 16G 内存主机分配 1000G 的 mmap 内存空间）；
3. mmap 负责映射文件逻辑上一段连续的数据（物理上可以不连续存储）映射为连续内存，而这里的文件可以是磁盘文件、驱动假造出的文件（例如 DMA 技术）以及设备；
4. mmap 由操作系统负责管理，对同一个文件地址的映射将被所有线程共享，操作系统确保线程安全以及线程可见性；

## 零拷贝

零拷贝（Zero-Copy）是一种计算机系统处理数据传输的技术，其核心思想是减少或消除在操作系统内核空间和用户空间之间传输数据时所需的数据复制操作。在传统的数据传输过程中，数据需要从磁盘（或其他数据源）复制到内核空间的缓冲区，然后再从内核空间复制到用户空间的应用程序缓冲区，这种多次复制消耗了大量的CPU资源和时间，尤其在处理大量数据时会影响系统性能。**零拷贝技术通过直接在内核空间进行数据传输，避免了数据在内核空间和用户空间之间的多次拷贝**。这样，数据可以直接从源地址发送到目的地址，而不需要在内核空间建立一个完整的数据副本。

### mmap

`mmap`是一个系统调用，它允许将文件或者其他对象映射到进程的地址空间。当一个文件被`mmap`映射后，文件的内容会在内存中占据一块地址空间，这样进程就可以直接通过内存地址访问文件内容，而不需要进行数据拷贝。

### write

`write`系统调用用于将数据从用户空间写入到文件描述符指向的文件中。在零拷贝的场景中，`write`用于将`mmap`映射的内存区域中的数据直接传输到网络套接字，从而避免了数据从用户空间到内核空间的拷贝。

### mmap + write 实现零拷贝

以下是使用`mmap`和`write`实现零拷贝的基本步骤：

1. **打开文件**：使用`open`系统调用打开需要传输的文件，获取文件描述符。
2. **内存映射**：使用`mmap`系统调用将文件映射到内存中。这会创建一个内存映射区域，进程可以通过读写这个区域来访问文件内容。
3. **设置套接字**：创建一个普通的TCP或UDP套接字，并绑定到一个端口上，以便接收数据。
4. **写入数据**：使用`write`系统调用将内存映射区域中的数据直接发送到套接字。在这个过程中，数据不需要从用户空间复制到内核空间，因为`mmap`已经将文件内容映射到了内存中，`write`操作可以直接在内核空间进行。
5. **关闭资源**：传输完成后，关闭文件描述符和套接字，解除内存映射。

# 12. Springboot启动流程

[https://juejin.cn/post/7035910505810100255#heading-13](https://juejin.cn/post/7035910505810100255#heading-13)

[https://www.jianshu.com/p/dc12081b3598](https://www.jianshu.com/p/dc12081b3598)

[https://juejin.cn/post/7144912826543865893](https://juejin.cn/post/7144912826543865893)

- **Spring Boot应用的主类**：每个Spring Boot项目都有一个标注了`@SpringBootApplication`注解的主类，这个类是应用的入口。这个类调用`SpringApplication.run()`方法，启动应用的启动流程。
- **核心注解**：`@SpringBootApplication`注解包含了三个核心注解：
    - `@SpringBootConfiguration`：作为`@Configuration`注解的包装，表示当前类为配置类。
    - `@EnableAutoConfiguration`：通过扫描类路径中的类并将它们注册为bean，从而促进自动配置。它依赖于`@AutoConfigurationPackage`和`@Import(AutoConfigurationImportSelector.class)`来自动加载配置类。
    - `@ComponentScan`：扫描并注册当前包及子包中带有`@Component`、`@Controller`、`@Service`、`@Repository`等注解的类。
- **启动过程**：启动包含两个主要阶段：构造`SpringBootApplication`对象和执行`run`方法。构造阶段通过确定Web环境、扫描获得初始化器和监听器以及定位main方法。`run`方法进一步设置应用上下文，处理环境设置，初始化bean，并刷新上下文。
- **Refresh方法**：此方法在bean生命周期管理中非常关键，包括bean的实例化和初始化。贯穿springbean的生命周期，执行bean的生命周期的前后置钩子方法，并且处理spring的注解标注的类。在onRefresh中通过Java代码构建出tomcat容器并启动。

这一分解为理解Spring Boot的启动过程提供了一个结构化的方法，强调了核心注解的重要性、构造和运行阶段以及refresh方法在bean生命周期管理中的作用。

# 13. Java序列化方式

[https://javaguide.cn/java/basis/serialization.html](https://javaguide.cn/java/basis/serialization.html)

- **序列化**：将数据结构或对象转换成二进制字节流的过程，**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

实现方式：

1. JDK 自带的序列化，只需实现 `java.io.Serializable`接口即可。
2. Kryo

# 14. Java网络编程

[https://dunwu.github.io/javacore/pages/e4c818/#socket-和-serversocket](https://dunwu.github.io/javacore/pages/e4c818/#socket-%E5%92%8C-serversocket)

网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。套接字（Socket）使用 TCP 提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。

**Java 通过 Socket 和 ServerSocket 实现对 TCP 的支持**。Java 中的 Socket 通信可以简单理解为：**`java.net.Socket` 代表客户端，`java.net.ServerSocket` 代表服务端**，二者可以建立连接，然后通信。

以下为 Socket 通信中建立建立的基本流程：

- 服务器实例化一个 `ServerSocket` 对象，表示服务器绑定一个端口。
- 服务器调用 `ServerSocket` 的 `accept()` 方法，该方法将一直等待，直到客户端连接到服务器的绑定端口（即监听端口）。
- 服务器监听端口时，客户端实例化一个 `Socket` 对象，指定服务器名称和端口号来请求连接。
- `Socket` 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。
- 在服务器端，`accept()` 方法返回服务器上一个新的 `Socket` 引用，该引用连接到客户端的 `Socket` 。

连接建立后，可以通过使用 IO 流进行通信。每一个 `Socket` 都有一个输出流和一个输入流。客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。

```java
// 服务端
public class HelloServer {

    public static void main(String[] args) throws Exception {
        // Socket 服务端
        // 服务器在8888端口上监听
        ServerSocket server = new ServerSocket(8888);
        System.out.println("服务器运行中，等待客户端连接。");
        // 得到连接，程序进入到阻塞状态
        Socket client = server.accept();
        // 打印流输出最方便
        PrintStream out = new PrintStream(client.getOutputStream());
        // 向客户端输出信息
        out.println("hello world");
        client.close();
        server.close();
        System.out.println("服务器已向客户端发送消息，退出。");
    }

}

// 客户端
public class HelloClient {

    public static void main(String[] args) throws Exception {
        // Socket 客户端
        Socket client = new Socket("localhost", 8888);
        InputStreamReader inputStreamReader = new InputStreamReader(client.getInputStream());
        // 一次性接收完成
        BufferedReader buf = new BufferedReader(inputStreamReader);
        String str = buf.readLine();
        buf.close();
        client.close();
        System.out.println("客户端接收到服务器消息：" + str + "，退出");
    }

}
```

# 15. execute和submit的区别

- `execute()`方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；
- `submit()`方法用于提交需要返回值的任务。线程池会返回一个 `Future` 类型的对象，通过这个 `Future` 对象可以判断任务是否执行成功，并且可以通过 `Future` 的 `get()`方法来获取返回值，`get()`方法会阻塞当前线程直到任务完成，而使用 `get（long timeout，TimeUnit unit）`方法的话，如果在 `timeout` 时间内任务还没有执行完，就会抛出 `java.util.concurrent.TimeoutException`。

# 16. Spring如何实现单例Bean

[https://blog.51cto.com/u_16099341/9817837](https://blog.51cto.com/u_16099341/9817837)

Spring为实现单例类可继承，使用的是单例注册表的方式（登记式单例）。
单例注册表单例实际上维护的是一组单例类的实例，将这些实例存储到一个Map(登记簿)中，对于已经登记过的单例，则从工厂直接返回，对于没有登记的，则先登记，而后返回。

1. 利用synchronized关键字锁定singletonCache（即单例注册表），检查里面是都有需要的bean
2. 若有，则直接返回
3. 没有，则取得Bean的定义，根据Bean定义判断是否是单例的。若是单例的，首先需要利用synchronized关键字锁定singletonCache，再次检查下singletonCache是否已有Bean实例（防止在程序执行过程中已有其他线程创建了该Bean实例）。若没有，则会真正的创建Bean实例，并添加到singletonCache中。

```java
public abstract class AbstractBeanFactory implements ConfigurableBeanFactory
{    
   /**  
    * 充当了Bean实例的缓存，实现方式和单例注册表相同  
    */    
   private final Map singletonCache=new HashMap();    
   public Object getBean(String name)throws BeansException{    
       return getBean(name,null,null);    
   }    
    ...    
   public Object getBean(String name,Class requiredType,Object[] args)throws BeansException
   {    
      //对传入的Bean name稍做处理，防止传入的Bean name名有非法字符(或则做转码)    
      String beanName=transformedBeanName(name);    
      Object bean=null;    
      //手工检测单例注册表    
      Object sharedInstance=null;    
      //使用了代码锁定同步块，原理和同步方法相似，但是这种写法效率更高    
      synchronized(this.singletonCache){    
         sharedInstance=this.singletonCache.get(beanName);    
       }    
      if(sharedInstance!=null){    
         ...    
         //返回合适的缓存Bean实例    
         bean=getObjectForSharedInstance(name,sharedInstance);    
      }else{    
        ...    
        //取得Bean的定义    
        RootBeanDefinition mergedBeanDefinition=getMergedBeanDefinition(beanName,false);    
         ...    
        //根据Bean定义判断，此判断依据通常来自于组件配置文件的单例属性开关    
        //<bean id="date" class="java.util.Date" scope="singleton"/>    
        //如果是单例，做如下处理    
        if(mergedBeanDefinition.isSingleton()){    
           synchronized(this.singletonCache){    
            //再次检测单例注册表    
             sharedInstance=this.singletonCache.get(beanName);    
             if(sharedInstance==null){    
                ...    
               try {    
                  //真正创建Bean实例    
                  sharedInstance=createBean(beanName,mergedBeanDefinition,args);    
                  //向单例注册表注册Bean实例    
                   addSingleton(beanName,sharedInstance);    
               }catch (Exception ex) {    
                  ...    
               }finally{    
                  ...    
              }    
             }    
           }    
          bean=getObjectForSharedInstance(name,sharedInstance);    
        }    
       //如果是非单例，即prototpye，每次都要新创建一个Bean实例    
       //<bean id="date" class="java.util.Date" scope="prototype"/>    
       else{    
          bean=createBean(beanName,mergedBeanDefinition,args);    
       }    
}    
...    
   return bean;    
}    
}
```

# 17. Spring循环依赖

[https://developer.aliyun.com/article/766880](https://developer.aliyun.com/article/766880)

Spring解决循环依赖是有前置条件的：

1. 出现循环依赖的Bean必须要是单例
2. 依赖注入的方式**不能全是**构造器注入的方式（很多博客上说，只能解决setter方法的循环依赖，这是错误的）

# 18. RPC

[https://javaguide.cn/distributed-system/rpc/rpc-intro.html](https://javaguide.cn/distributed-system/rpc/rpc-intro.html)

**RPC（Remote Procedure Call）** 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。

两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。

简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。

举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。

一言蔽之：**RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。**

**RPC原理：**

1. 服务消费端（client）以本地调用的方式调用远程服务；
2. 客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：`RpcRequest`；
3. 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；
4. 服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: `RpcRequest`；
5. 服务端 Stub（桩）根据`RpcRequest`中的类、方法、方法参数等信息调用本地的方法；
6. 服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：`RpcResponse`（序列化）发送至消费方；
7. 客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:`RpcResponse` ，这样也就得到了最终结果。over!