# 20240327蚂蚁一面

# 项目

1. 有没有对数据分页？
2. es分词：IK Max_Word

# 八股

## https加密

## 对称加密、非对称加密算法

[https://zhuanlan.zhihu.com/p/347114235](https://zhuanlan.zhihu.com/p/347114235)

## java线程的状态以及状态之间如何变化

## java创建线程的方式

## 设置线程池大小需要考虑的地方

## java线程安全如何保证

[https://blog.csdn.net/weixin_42641909/article/details/103595036](https://blog.csdn.net/weixin_42641909/article/details/103595036)

## hashmap线程安全吗

## mysql事务隔离级别

## spring自动装配

## 缓存穿透、缓存击穿、缓存雪崩

## java包的冲突如何解决

[https://blog.csdn.net/noaman_wgs/article/details/81137893](https://blog.csdn.net/noaman_wgs/article/details/81137893)

### java包冲突产生

> A->B->C->D1(log 15.0)：A中包含对B的依赖，B中包含对C的依赖，C中包含对D1的依赖，假设是D1是日志jar包，version为15.0

E->F->D2(log 16.0)：E中包含对F的依赖，F包含对D2的依赖，假设是D2是同一个日志jar包，version为16.0
> 

当pom.xml文件中引入A、E两个依赖后，根据Maven传递依赖的原则，D1、D2都会被引入，而D1、D2是同一个依赖D的不同版本。
当我们在调用D2中的method1()方法，而D1中是15.0版本（method1可能是D升级后增加的方法），可能没有这个方法，这样JVM在加载A中D1依赖的时候，找不到method1方法，就会报NoSuchMethodError的错误，此时就产生了jar包冲突。

### **解决方案**

Maven 解析 pom.xml 文件时，同一个 jar 包只会保留一个，那么面对多个版本的jar包，需要怎么解决呢？

1. **Maven默认处理策略**
    1. 最短路径优先：Maven 面对 D1 和 D2 时，会默认选择最短路径的那个 jar 包，即 D2。E->F->D2 比 A->B->C->D1 路径短 1。
    2. 最先声明优先：如果路径一样的话，如： A->B->C1, E->F->C2 ，两个依赖路径长度都是 2，那么就选择最先声明。
2. **移除依赖：用于排除某项依赖的依赖jar包。**可以借助Maven Helper插件中的Dependency Analyzer分析冲突的jar包，然后在对应标红版本的jar包上面点击execlude，就可以将该jar包排除出去。（mvn分析包冲突命令：`mvn dependency:tree`）
3. **版本锁定原则：一般用在继承项目的父项目中。**正常项目都是多模块的项目，如moduleA和moduleB共同依赖X这个依赖的话，那么可以将X抽取出来，同时设置其版本号，这样X依赖在升级的时候，不需要分别对moduleA和moduleB模块中的依赖X进行升级，避免太多地方（moduleC、moduleD…）引用X依赖的时候忘记升级造成jar包冲突，这也是实际项目开发中比较常见的方法。

## 排行榜设计

[https://www.yuque.com/snailclimb/tangw3/at9ogbghb5090sh0](https://www.yuque.com/snailclimb/tangw3/at9ogbghb5090sh0)

## 多个人抢答题目如何实现

[https://www.yuque.com/snailclimb/tangw3/dmi5t01gacg3wa5u](https://www.yuque.com/snailclimb/tangw3/dmi5t01gacg3wa5u)

**单机情况下**，用JVM本地锁（synchronized之类的）

**分布式情况下：**

分布式锁，基于 Redis 实现分布式锁。在 Redis 中， `SETNX`（**SET** if **N**ot e**X**ists） 命令是可以帮助我们实现互斥。为了防止误删到其他的锁，建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。

![Untitled](20240327%E8%9A%82%E8%9A%81%E4%B8%80%E9%9D%A2%2073dee83827484286b8e7ee30dbb4d6a4/Untitled.png)

为了避免锁无法被释放，可以**给这个 key（也就是锁） 设置一个过期时间** 。如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。因此需要实现锁的续期。

Java的Redisson实现了这个功能。Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的**Watch Dog（ 看门狗）**，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。

**Redisson**内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。

---

也可以利用数据库行锁来做。

## 项目中用到的设计模式

## JVM垃圾回收机制

## JDK新特性有没有应用

JDK8 lamada表达式

```java
List<Integer> strings = Arrays.asList(1, 2, 3);

Collections.sort(strings, new Comparator<Integer>() {
@Override
public int compare(Integer o1, Integer o2) {
    return o1 - o2;}
});

//Lambda
Collections.sort(strings, (Integer o1, Integer o2) -> o1 - o2);
//分解开
Comparator<Integer> comparator = (Integer o1, Integer o2) -> o1 - o2;
Collections.sort(strings, comparator);
```